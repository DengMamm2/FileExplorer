<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Performance File Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .path-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .loading-bar {
            height: 3px;
            background: #007bff;
            width: 0%;
            transition: width 0.3s ease;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1000;
        }

        .main-content {
            height: calc(100vh - 60px);
            display: flex;
        }

        .sidebar {
            width: 250px;
            background: #fff;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
        }

        .file-grid {
            flex: 1;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .virtual-scroll-container {
            height: 100%;
            overflow: auto;
            position: relative;
        }

        .virtual-scroll-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            padding: 10px;
        }

        .file-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .file-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            border-color: #007bff;
        }

        .file-item.directory {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .file-thumbnail {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 10px;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .file-thumbnail img {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
        }

        .file-thumbnail.loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .file-icon {
            font-size: 48px;
            margin-bottom: 10px;
            opacity: 0.7;
        }

        .file-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 5px;
            word-break: break-word;
            line-height: 1.3;
        }

        .file-info {
            font-size: 12px;
            color: #666;
            opacity: 0.8;
        }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #fff;
            border-top: 1px solid #e0e0e0;
            padding: 8px 20px;
            font-size: 12px;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .performance-stats {
            display: flex;
            gap: 20px;
        }

        .error-message {
            background: #ff4444;
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            margin: 10px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .scan-progress {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
        }

        .progress-bar {
            width: 300px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: #007bff;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .thumbnail-quality-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .thumbnail-quality-toggle input[type="checkbox"] {
            margin: 0;
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
            
            .virtual-scroll-content {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 10px;
                padding: 5px;
            }
            
            .file-item {
                padding: 10px;
            }
            
            .file-thumbnail {
                height: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="loading-bar" id="loadingBar"></div>
    
    <div class="header">
        <button onclick="navigateUp()">↑ Up</button>
        <input type="text" class="path-input" id="pathInput" placeholder="Enter directory path..." />
        <div class="controls">
            <div class="thumbnail-quality-toggle">
                <input type="checkbox" id="highQualityThumbnails" checked />
                <label for="highQualityThumbnails">HQ Thumbnails</label>
            </div>
            <button onclick="refreshDirectory()">Refresh</button>
            <button onclick="toggleRealTimeMode()" id="realTimeBtn">Real-time: OFF</button>
        </div>
    </div>

    <div class="main-content">
        <div class="sidebar" id="sidebar">
            <!-- Quick access folders will be added here -->
        </div>
        
        <div class="file-grid">
            <div class="virtual-scroll-container" id="scrollContainer">
                <div class="virtual-scroll-content" id="fileGrid">
                    <!-- Files will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div>
            <span id="itemCount">0 items</span> | 
            <span id="selectedPath">No directory selected</span>
        </div>
        <div class="performance-stats">
            <span>Load Time: <span id="loadTime">-</span>ms</span>
            <span>Memory: <span id="memoryUsage">-</span>MB</span>
        </div>
    </div>

    <script>
        class HighPerformanceFileExplorer {
            constructor() {
                this.currentPath = '';
                this.currentItems = [];
                this.isLoading = false;
                this.realTimeMode = false;
                this.websocket = null;
                this.loadStartTime = 0;
                this.thumbnailCache = new Map();
                this.observedThumbnails = new Set();
                
                this.initializeWebSocket();
                this.setupIntersectionObserver();
                this.setupEventListeners();
                this.loadDirectory(this.getInitialPath());
                this.updatePerformanceStats();
            }

            getInitialPath() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('path') || '/home/runner/work/FileExplorer/FileExplorer';
            }

            initializeWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                
                try {
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleWebSocketMessage(data);
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocket connection closed');
                        // Attempt to reconnect after 5 seconds
                        setTimeout(() => this.initializeWebSocket(), 5000);
                    };
                } catch (error) {
                    console.error('WebSocket connection failed:', error);
                }
            }

            setupIntersectionObserver() {
                this.thumbnailObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.loadThumbnail(entry.target);
                        }
                    });
                }, {
                    rootMargin: '50px'
                });
            }

            setupEventListeners() {
                document.getElementById('pathInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.loadDirectory(e.target.value);
                    }
                });

                // Handle scroll for infinite loading
                const scrollContainer = document.getElementById('scrollContainer');
                scrollContainer.addEventListener('scroll', this.throttle(() => {
                    if (scrollContainer.scrollTop + scrollContainer.clientHeight >= 
                        scrollContainer.scrollHeight - 200) {
                        this.loadMoreItems();
                    }
                }, 100));
            }

            async loadDirectory(path, page = 0) {
                if (this.isLoading && page === 0) return;
                
                this.isLoading = true;
                this.loadStartTime = performance.now();
                this.updateLoadingBar(10);

                try {
                    const highQuality = document.getElementById('highQualityThumbnails').checked;
                    const response = await fetch(
                        `/api/directory?path=${encodeURIComponent(path)}&page=${page}&limit=50&thumbnails=${highQuality}`
                    );
                    
                    if (!response.ok) throw new Error('Failed to load directory');
                    
                    const data = await response.json();
                    this.updateLoadingBar(60);
                    
                    if (page === 0) {
                        this.currentPath = data.path;
                        this.currentItems = data.items;
                        this.renderItems(data.items, true);
                    } else {
                        this.currentItems.push(...data.items);
                        this.renderItems(data.items, false);
                    }
                    
                    this.updateUI(data);
                    this.updateLoadingBar(100);
                    
                    // Update performance stats
                    const loadTime = performance.now() - this.loadStartTime;
                    document.getElementById('loadTime').textContent = Math.round(loadTime);
                    
                } catch (error) {
                    this.showError(error.message);
                } finally {
                    this.isLoading = false;
                    setTimeout(() => this.updateLoadingBar(0), 500);
                }
            }

            renderItems(items, clearFirst = false) {
                const fileGrid = document.getElementById('fileGrid');
                
                if (clearFirst) {
                    fileGrid.innerHTML = '';
                    this.observedThumbnails.clear();
                }

                const fragment = document.createDocumentFragment();
                
                items.forEach(item => {
                    const itemElement = this.createFileElement(item);
                    fragment.appendChild(itemElement);
                });
                
                fileGrid.appendChild(fragment);
                
                // Observe new thumbnail elements
                this.observeThumbnails();
            }

            createFileElement(item) {
                const div = document.createElement('div');
                div.className = `file-item ${item.isDirectory ? 'directory' : ''}`;
                div.onclick = () => this.handleItemClick(item);
                
                const thumbnailDiv = document.createElement('div');
                thumbnailDiv.className = 'file-thumbnail';
                
                if (item.isDirectory) {
                    thumbnailDiv.innerHTML = '<div class="file-icon">📁</div>';
                } else if (item.hasThumbnail) {
                    thumbnailDiv.className += ' loading';
                    thumbnailDiv.dataset.thumbnailUrl = item.thumbnailUrl;
                    thumbnailDiv.dataset.itemPath = item.path;
                } else {
                    const icon = this.getFileIcon(item.type);
                    thumbnailDiv.innerHTML = `<div class="file-icon">${icon}</div>`;
                }
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'file-name';
                nameDiv.textContent = item.name;
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'file-info';
                if (item.isDirectory) {
                    infoDiv.textContent = 'Folder';
                } else {
                    infoDiv.textContent = this.formatFileSize(item.size);
                }
                
                div.appendChild(thumbnailDiv);
                div.appendChild(nameDiv);
                div.appendChild(infoDiv);
                
                return div;
            }

            observeThumbnails() {
                const thumbnails = document.querySelectorAll('.file-thumbnail[data-thumbnail-url]:not(.observed)');
                thumbnails.forEach(thumbnail => {
                    thumbnail.classList.add('observed');
                    this.thumbnailObserver.observe(thumbnail);
                });
            }

            async loadThumbnail(thumbnailElement) {
                const url = thumbnailElement.dataset.thumbnailUrl;
                const path = thumbnailElement.dataset.itemPath;
                
                if (!url || this.observedThumbnails.has(path)) return;
                
                this.observedThumbnails.add(path);
                
                try {
                    // Check cache first
                    if (this.thumbnailCache.has(url)) {
                        const cachedBlob = this.thumbnailCache.get(url);
                        this.displayThumbnail(thumbnailElement, cachedBlob);
                        return;
                    }
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const blob = await response.blob();
                        
                        // Cache the thumbnail
                        this.thumbnailCache.set(url, blob);
                        
                        // Limit cache size
                        if (this.thumbnailCache.size > 200) {
                            const firstKey = this.thumbnailCache.keys().next().value;
                            this.thumbnailCache.delete(firstKey);
                        }
                        
                        this.displayThumbnail(thumbnailElement, blob);
                    }
                } catch (error) {
                    console.error('Failed to load thumbnail:', error);
                    thumbnailElement.classList.remove('loading');
                }
            }

            displayThumbnail(thumbnailElement, blob) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(blob);
                img.onload = () => {
                    thumbnailElement.innerHTML = '';
                    thumbnailElement.appendChild(img);
                    thumbnailElement.classList.remove('loading');
                };
            }

            handleItemClick(item) {
                if (item.isDirectory) {
                    this.loadDirectory(item.path);
                } else {
                    this.previewFile(item);
                }
            }

            previewFile(item) {
                // Open file preview or download
                window.open(`/api/metadata/${encodeURIComponent(item.path)}`, '_blank');
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'scan_start':
                        this.showScanProgress(data.path);
                        break;
                    case 'scan_batch':
                        this.updateScanProgress(data.progress, data.items.length);
                        this.renderItems(data.items, false);
                        break;
                    case 'scan_complete':
                        this.hideScanProgress();
                        break;
                    case 'scan_error':
                        this.hideScanProgress();
                        this.showError(data.message);
                        break;
                }
            }

            updateUI(data) {
                document.getElementById('pathInput').value = data.path;
                document.getElementById('selectedPath').textContent = data.path;
                document.getElementById('itemCount').textContent = `${data.total} items`;
                
                // Update URL
                const url = new URL(window.location);
                url.searchParams.set('path', data.path);
                window.history.pushState({}, '', url);
            }

            updateLoadingBar(percentage) {
                const loadingBar = document.getElementById('loadingBar');
                loadingBar.style.width = percentage + '%';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);
                
                setTimeout(() => {
                    document.body.removeChild(errorDiv);
                }, 5000);
            }

            showScanProgress(path) {
                const progressDiv = document.createElement('div');
                progressDiv.className = 'scan-progress';
                progressDiv.id = 'scanProgress';
                progressDiv.innerHTML = `
                    <h3>Scanning Directory</h3>
                    <p>${path}</p>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <p id="progressText">0%</p>
                `;
                document.body.appendChild(progressDiv);
            }

            updateScanProgress(percentage, itemCount) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                if (progressFill && progressText) {
                    progressFill.style.width = percentage + '%';
                    progressText.textContent = `${percentage}% (${itemCount} items)`;
                }
            }

            hideScanProgress() {
                const progressDiv = document.getElementById('scanProgress');
                if (progressDiv) {
                    document.body.removeChild(progressDiv);
                }
            }

            getFileIcon(type) {
                const icons = {
                    'image': '🖼️',
                    'video': '🎬',
                    'audio': '🎵',
                    'document': '📄',
                    'archive': '📦',
                    'unknown': '📄'
                };
                return icons[type] || icons.unknown;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }

            throttle(func, limit) {
                let inThrottle;
                return function() {
                    const args = arguments;
                    const context = this;
                    if (!inThrottle) {
                        func.apply(context, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                }
            }

            updatePerformanceStats() {
                if (performance.memory) {
                    const memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    document.getElementById('memoryUsage').textContent = memory;
                }
                
                setTimeout(() => this.updatePerformanceStats(), 2000);
            }

            loadMoreItems() {
                // Implementation for infinite scroll if needed
                console.log('Load more items triggered');
            }
        }

        // Global functions for button handlers
        function navigateUp() {
            const pathInput = document.getElementById('pathInput');
            const currentPath = pathInput.value;
            const parentPath = currentPath.split('/').slice(0, -1).join('/') || '/';
            explorer.loadDirectory(parentPath);
        }

        function refreshDirectory() {
            const pathInput = document.getElementById('pathInput');
            explorer.loadDirectory(pathInput.value);
        }

        function toggleRealTimeMode() {
            const btn = document.getElementById('realTimeBtn');
            explorer.realTimeMode = !explorer.realTimeMode;
            btn.textContent = `Real-time: ${explorer.realTimeMode ? 'ON' : 'OFF'}`;
            
            if (explorer.realTimeMode && explorer.websocket) {
                const pathInput = document.getElementById('pathInput');
                explorer.websocket.send(JSON.stringify({
                    type: 'scan_directory',
                    path: pathInput.value
                }));
            }
        }

        // Initialize the file explorer
        const explorer = new HighPerformanceFileExplorer();
    </script>
</body>
</html>